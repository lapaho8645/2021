## 시그널과 좀비 프로세스
* 커널에서 자식 프로세스가 종료되는 시점에서 반환 값을 부모 프로세스가 읽어갈 때까지 완전히 소멸시키지 않기 때문에 좀비 프로세스가 발생
* 자식 프로세스가 종료하며 발생시키는 SIGCHLD를 부모 프로세스가 받아 처리해야 한다.
#### 시그널 등록과 처리
```c
#include <signal.h>
int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
//signum에 대해 어떤 처리를 할지(act)에 대한 함수, oldact는 호출하기 전 설정된 처리 정보

struct sigaction{
  void (*sa_handler) (int)
  void (*sa_sigaction) (int, siginfo_t *, void *)   //sa_flags가 SA_SIGINFO일 떄 sa_handler 대신에 동작하는 핸들러
  sigset_t sa_mask;         //시그널 처리기를 수행할 때 차단될 시그널
  int sa_flags;             
  void (*sa_restorer) (void);
}
```
#### 시그널 핸들러 예제
```c 
#include <stdio.h>
#include <signal.h>

struct sigaction act_new;
struct sigaction act_old;

void
sig_handler(int signo)
{
	printf( "First Ctrl-C pressed !! \n");
	11 
	sigaction(SIGINT, &act_old, NULL);      //SIGINT 시그널에 다시 종료 처리를 설정
}

int main(void)
{
	act_new.sa_handler = sig_handler;
	sigemptyset(&act_new. sa_mask);
	act_new.sa_flags = 0;
	
	sigaction(SIGINT, &act_new, &act_old);      //SIGINT의 기본 처리였던 종료가 act_old에 저장 
	while(1)
	{
		printf("sigaction test \n");
		sleep(1);
	}
}
```
