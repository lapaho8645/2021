## HTTP/1.1 프로토콜
TCP 연결 기반 비연결성 프로토콜이기 때문에 오버헤드가 발생한다.
#### Keep alive 기능
* 한 번 연결된 접속을 유지하여 불필요한 핸드 셰이크를 줄임으로써 응답시간을 개선할 수 있게 하였다.
#### Pipelining
* 하나의 커넥션에서 한번에 순차적인 여러 요청을 연속적으로 하고 그 순서에 맞춰 응답 받는 방식으로 지연 시간을 줄임 
* 순차적으로 요청하고 응답을 받아야 하기 때문에 먼저 받은 요청이 끝나지 않으면 뒤에 있는 요청 처리가 늦어지는 HOL(Head of Line) Blocking 문제 발생
![image](https://user-images.githubusercontent.com/64197428/132609769-c1e1e159-c428-44f5-853a-b7e7199b66e7.png)

## HTTP/2 프로토콜
HTTP/2 프로토콜은 서버와 클라이언트 둘 다 HTTP/2를 지원해야 사용 가능하다.

햔 쪽만 HTTP/2를 지원한다면 해당 통신은 구버전의 프로토콜로 fall-back된다.
#### 바이너리 프레임
* 더 작은 메시지와 프레임으로 분할되며, 각각은 바이너리 형식으로 인코딩된다. 따라서 바이너리 프레임을 지원하지 않는 이전 버전과는 통신이 불가능하다.
#### 멀티 플렉싱
* 하나의 연결로 여러 메시지를 동시에 주고 받을 수 있어 지연 시간을 줄일 수 있다.
* 한번에 여러 요청을 연속적으로 하고 순서에 상관 없이 응답을 받는 방식
## HTTP/2 지원 여부 판별
#### http
1. 클라이언트는 HTTP/2지원 여부를 알고 싶어 header Upgrade 필드에 h2c를 넣어 서버에 전송
2. 서버는 '200 OK'라고 응답하거나 '101'로 응답
3. '200 OK'라고 응답한 서버는 HTTP/1.1만 지원하는 서버이고 '101'로 응답한 서버는 HTTP/2를 지원하는 서버이다.
#### https
1. 클라이언트는 TLS 기반의 https URI로 접속하면서 ALPN(Application-Layer Protocol Negotiation)을 사용하게 됨
> ALPN이란 Layer 7에서 클라이언트와 서버가 상호 협의하에 사용할 프로토콜을 결정하는 방식
2. 클라이언트는 후보 프로토콜 집합을 ALPN extension 값으로 전달
3. 서버는 자신이 지원하는 프로토콜을 고른다.
4. 서버가 고른 프로토콜의 ALPN extension 값이 h2면 HTTP/2 지원



