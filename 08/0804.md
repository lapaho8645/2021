## simultaneous execution
```c
/**********************simultaneous.c***********************/
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>

#define LOOP_COUNTER 10000

void *thread_function1(void *arg);
void *thread_function2(void *arg);

int counter;            //전역 변수

int main(){
    int res1, res2;
    pthread_t a_thread1, a_thread2;
    void *thread_result;

    res1 = pthread_create(&a_thread1, NULL, thread_function1, NULL);
    res2 = pthread_create(&a_thread2, NULL, thread_function2, NULL);
    if(res1 != 0){
        perror("Thread creation failed");
        exit(EXIT_FAILURE);
    }
    if(res2 != 0){
        perror("Thread creation failed");
        exit(EXIT_FAILURE);
    }
    res1 = pthread_join(a_thread1, &thread_result);
    res2 = pthread_join(a_thread2, &thread_result);

    printf("main: Final counter: %d\n", counter);

    exit(EXIT_SUCCESS);
}

void *thread_function1(void *arg){
    int i = 0;
    for(i = 0; i < LOOP_COUNTER;i++){
        counter = counter +1;
    }
    pthread_exit("Thank you for the CPU time");
}

void *thread_function2(void *arg){
    int i = 0;
    for(i = 0; i < LOOP_COUNTER;i++){
        counter = counter -1;
    }
}
```
* 코드 실행 결과
![image](https://user-images.githubusercontent.com/64197428/128106178-a7efc694-a863-4a52-b66a-746e9a323e5a.png)
> 0이 나오는 것이 맞는 결과지만 실행할 때마다 다른 결과가 나옴
> 레지스터에 counter값을 저장하고 값 변경 후 counter에 레지스터 값을 저장하는 과정이 수행되는데 이 과정에서 context switching이 발생하기 때문
> -> semaphore 사용

## Mutual exclusion : Semaphore
* int sem_init(sem_t *sem, int pshared, unsigned int value);
* 
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <pthread.h>
#include <semaphore.h>

#define LOOP_COUNTER 10000

void *thread_function1(void *arg);
void *thread_function2(void *arg);

int counter;            //전역 변수
sem_t bin_sem;

int main(){
    int res1, res2;
    pthread_t a_thread1, a_thread2;
    void *thread_result;

    res1 = sem_init(&bin_sem, 0, 1);
    if(res1 != 0){
        perror("Semaphore initialization failed");
        exit(EXIT_FAILURE);
    }

   .....
   .....
}

void *thread_function1(void *arg){
    int i = 0;
    for(i = 0; i < LOOP_COUNTER;i++){
        sem_wait(&bin_sem);       
        counter = counter +1;
        sem_post(&bin_sem);
    }
    pthread_exit("Thank you for the CPU time");
}

void *thread_function2(void *arg){
    int i = 0;
    for(i = 0; i < LOOP_COUNTER;i++){
        sem_wait(&bin_sem);
        counter = counter -1;
        sem_post(&bin_sem);
    }
    pthread_exit("Thank you for the CPU time");
}
```

## Mutual exclusion : Mutex


