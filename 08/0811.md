## 공유 메모리
* 공유 메모리 공간을 관리하기 위한 구조체 shimid_ds
```c
struct shmid_ds
{
  struct          ip c_perm shm_perm;       //동작 허가 사항
  int             shm_segz;                 //세그먼트 크기
  time_t          shm_atime;                //마지막 attach 시간
  time_t          shm_dtime;                //마지막 detach 시간 
  time_t          shm_ctime;                //마지막 change 시간
  unsigned short  shm_cpid;                 //생성자의 pid
  unsigned short  shm_lpid;                 //마지막 동작자의 pid
  short           shm_nattch;               //현재 접근한 프로세스 수
}
* 공유 메모리 예제
```c

#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>
#include <sys/wait.h>
#include <string.h>
#include <unistd.h>
#include <time.h>

#define SHARED_MEMORY_KEY 1234      //공유메모리를 구별하는 키 값
#define INIT_VALUE 3
#define MAX_VALUE 6
#define MIN_VALUE 0
#define RAND_DISTANCE 5

int main()
{
    int shmid;        //공유메모리의 id 저장
    int pid;
    int *cal_num;           
    int sleep_time=0;
    int status;
    int seed1, seed2;

    srand(time(NULL));
    seed1 = rand();       //부모 프로세스 난수 
    seed2 = rand();       //자식 프로세스 난수

    // make space that shared-memory
    shmid = shmget((key_t)SHARED_MEMORY_KEY, sizeof(int), 0666 | IPC_CREAT);      //최소 사이즈를 4바이트로 설정하고 SHARED_MEMORY_KEY를 키로 하는 공유 메모리 생성
                                                                                  //메모리가 생성되지 않은 경우 새로 생성
    if(shmid == -1){
        perror("shmget failed : ");
        exit(0);
    }

    cal_num = (int *)shmat(shmid, NULL, 0);         //cal_num에 공유 메모리 포인터 값을 저장
    if(cal_num ==(int *)-1){
        perror("shmat failed : ");
        exit(0);
    }
    *cal_num = INIT_VALUE;

    // make child process
    pid = fork();

    //child process
    if(pid == 0){
        srand(seed2);
        while(1){
            if((*cal_num) >= MAX_VALUE || (*cal_num)<= MIN_VALUE){
                break;
            }
            *cal_num = *cal_num + 1;
            printf("child : I'm %d sec sleep. plus 1. current value %d\n", sleep_time, *cal_num);
            sleep_time = (rand()%RAND_DISTANCE) +1;
            sleep(sleep_time);
        }
        if((*cal_num) >= MAX_VALUE){
            puts("child : I'm winner\n");
        }
        else{
            puts("child : I'm looser\n");
        }
        shmdt(cal_num);           //공유 메모리와 접속을 끊음
    }

    // parent process
    else{
        srand(seed1);
        while(1){
            if((*cal_num) >= MAX_VALUE || (*cal_num)<= MIN_VALUE){
                break;
            }
            *cal_num = *cal_num - 1;
            printf("parent :  I'm %d sec sleep. minus 1. current value: %d\n", sleep_time, *cal_num);
            sleep_time = (rand()%RAND_DISTANCE) +1;
            sleep(sleep_time);
        }
        if((*cal_num) >= MAX_VALUE){
            puts("parent : I'm looser\n");
        }
        else{
            puts("parent : I'm winner\n");
        }
        shmdt(cal_num);       //공유 메모리와 접속을 끊음
        shmctl(shmid, IPC_RMID, NULL);    //공유 메모리에 접속해있는 프로세스가 없을 때 공유메모리 공간 삭제
        waitpid(pid, &status, 0);       //자식 프로세스가 종료될 때까지 대기
    }
    return 0;
}
```
